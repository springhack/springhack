

<p><span style="white-space:pre">	</span>早年我就学了这个？不敢相信我那时这么激情澎湃。。。。。转载的，同样来源不明，知道的要告诉我哦，里面的内容很基础。。。。。</p><p></p><p>提起面向对象我们就能想到类，对象，封装，继承，多态。在《javaScript高级程序设计》（人民邮电出版社，曹力、张欣译。英文名字是：Professional JavaScript for Web Developers）这本书中描述的还算比较详细。我们看看JavaScript中定义类的各种方法。</p><p><span style="font-family:inherit;">1．工厂方式</span></p><p>&nbsp;&nbsp;&nbsp; javaScript中创建自己的类和对象，我们应该是必须掌握的，我们都知道javaScript中对象的属性可以在对象创建后动态定义，比如下面的代码：</p><p>&lt;script type=”text/javascript”&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//定义<br /></span>&nbsp;&nbsp;&nbsp; var oCar = new Object();<br />&nbsp;&nbsp;&nbsp; oCar.color = “red”;<br />&nbsp;&nbsp;&nbsp; oCar.doors = 4;<br />&nbsp;&nbsp;&nbsp; oCar.showColor = function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//调用<br /></span>&nbsp;&nbsp;&nbsp; oCar.showColor();<br />&lt;/script&gt;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; 我们很容易使用oCar对象，但是我们创就是想创建多个Car实例。我们可以使用一个函数来封装上面的代码来实现：&lt;script type=”text/javascript”&gt;<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp; //定义</span><br />&nbsp;&nbsp;&nbsp; function createCar() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var oCar = new Object();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oCar.color = “red”;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oCar.doors = 4;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oCar.showColor = function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oCar;<br />&nbsp;&nbsp;&nbsp; }<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp; //调用</span><br />&nbsp;&nbsp;&nbsp; var ocar1 = createCar();<br />&nbsp;&nbsp;&nbsp; var ocar2 = createCar();<br />&nbsp;&nbsp;&nbsp; ocar1.color = “black”;<br />&nbsp;&nbsp;&nbsp; ocar1.showColor();<br />&nbsp;&nbsp;&nbsp; ocar2.showColor();<br />&lt;/script&gt;</p><p>&nbsp;&nbsp;&nbsp; 顺便说一下，javaScript对象默认成员属性都是<span style="font-family:inherit;">public</span>&nbsp;的。这种方式我们称为<span style="font-family:inherit;">工厂方式</span>，我们创造了能创建并返回特定类型的对象的工厂。</p><p>&nbsp;&nbsp;&nbsp; 这样做有点意思了，但是在面向对象中我们经常使用创建对象的方法是：</p><p>Car car=new Car();</p><p>&nbsp;&nbsp;&nbsp; 使用new 关键字已经深入人心，因此我们使用上面的方法去定义总感觉别扭，并且每次调用时都去创建新的属性以及函数，功能上也不实际。下来我们看看构造函数的形式定义类。</p><p><span style="font-family:inherit;">2．构造函数</span></p><p>这种方式看起来有点象工厂函数。具体表现如下：</p><p>&lt;script type=”text/javascript”&gt;<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp; //定义</span><br />&nbsp;&nbsp;&nbsp; function Car(color, doors) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.color = color;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.doors = doors;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.showColor = function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; }<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp; //调用</span><br />&nbsp;&nbsp;&nbsp; var car1 = new Car(“red”, 4);<br />&nbsp;&nbsp;&nbsp; var car2 = new Car(“blue”, 4);<br />&nbsp;&nbsp;&nbsp; car1.showColor();<br />&nbsp;&nbsp;&nbsp; car2.showColor();<br />&lt;/script&gt;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; 看起来效果很明显，有差别了吧。感觉有点意思了。在构造函数内部创造对象使用this 关键字，使用new 运算符创建对象感觉非常亲切。但是也有点问题：每次new 对象时都会创建所有的属性，包括函数的创建，也就是说多个对象完全独立，我们定义类的目的就是为了共享方法以及数据，但是car1对象与car2对象都是各自独立的属性与函数，最起码我们应该共享方法。这就是原形方式的优势所在。</p><p><span style="font-family:inherit;">3．原型方式</span></p><p>利用对象的prototype属性，可把它看出创建新对象所依赖的原型。方法如下：</p><p>&lt;script type=”text/javascript”&gt;<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp; //定义</span><br />&nbsp;&nbsp;&nbsp; function Car() {<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; Car.prototype.color = “red”;<br />&nbsp;&nbsp;&nbsp; Car.prototype.doors = 4;<br />&nbsp;&nbsp;&nbsp; Car.prototype.drivers = new Array(“Tom”, “Jerry”);<br />&nbsp;&nbsp;&nbsp; Car.prototype.showColor = function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp; }<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp;&nbsp; //调用：</span><br />&nbsp;&nbsp;&nbsp; var car1 = new Car();<br />&nbsp;&nbsp;&nbsp; var car2 = new Car();<br />&nbsp;&nbsp;&nbsp; car1.showColor();<br />&nbsp;&nbsp;&nbsp; car2.showColor();<br />&nbsp;&nbsp;&nbsp; alert(car1.drivers);<br />&nbsp;&nbsp;&nbsp; car1.drivers.push(“stephen”);<br />&nbsp;&nbsp;&nbsp; alert(car1.drivers);&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//结果：Tom,Jerry,stephen<br /></span>&nbsp;&nbsp;&nbsp; alert(car2.drivers);&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//结果：Tom,Jerry,stephen</span></p><p><span style="font-family:inherit;color:rgb(0, 128, 0);">//可以用json方式简化prototype的定义:</span></p><p><span style="font-family:inherit;color:rgb(0, 128, 0);"><span style="font-family:inherit;color:rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Car.prototype =<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color: “red”,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doors: 4,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drivers: [“Tom”, “Jerry”,’safdad’],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; showColor: function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></span>&lt;/script&gt;</p><p>&nbsp;&nbsp;&nbsp; 首先这段代码的构造函数，其中没有任何代码，接下来通过对象的prototype属性添加属性定义Car对象的属性。这种方法很好，但是问题是Car的对象指向的是Array指针，Car的两个对象都指向同一个Array数组，其中一个对象car1改变属性对象的引用（数组Array）时，另一个对象car2也同时改变，这是不允许的。</p><p>&nbsp;&nbsp;&nbsp; 同时该问题也表现在原型不能带任何初始化参数，导致构造函数无法正常初始化。这需要另一种方式来解决：那就是混合的构造函数/原型模式。</p><p><span style="font-family:inherit;">4. 混合的构造函数/原型模式</span></p><p>联合使用构造函数和原型方式，定义类就非常方便。</p><p>&lt;script type=”text/javascript”&gt;<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">//定义</span><br />&nbsp;&nbsp;&nbsp; function Car(color,doors)<br />&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.color=color;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.doors=doors;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.drivers=new Array(“Tom”,”Jerry”);<br />&nbsp;&nbsp; }</p><p>&nbsp;&nbsp; Car.prototype.showColor=function(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp; }<br />&nbsp;&nbsp;<br /><span style="font-family:inherit;color:rgb(0, 128, 0);">&nbsp;&nbsp; //调用：</span><br />&nbsp;&nbsp; var car1=new Car(‘red’,4);<br />&nbsp;&nbsp; var car2=new Car(‘blue’,4);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp; car1.showColor();<br />&nbsp;&nbsp; car2.showColor();<br />&nbsp;&nbsp;<br />&nbsp;&nbsp; alert(car1.drivers);<br />&nbsp;&nbsp; car1.drivers.push(“stephen”);<br />&nbsp;&nbsp; alert(car1.drivers);&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//结果：Tom,Jerry,stephen<br /></span>&nbsp;&nbsp; alert(car2.drivers);&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//结果：Tom,Jerry<br /></span>&nbsp;&nbsp; alert(car1 instanceof Car);</p><p>&lt;/script&gt;</p><p>&nbsp;&nbsp;&nbsp; 该方法是把属性放在内部定义，把方法放在外边利用prototype进行定义。解决了第三种方法的问题。</p><p>&nbsp;&nbsp;&nbsp; 这种方法其实应该来说非常友好了，但是比起java的语法来，应该有一些不和谐，感觉比较凌乱，对C++来说，我们就没有那么麻烦的感觉了，可是开发C++的研发人员一般情况下很少涉及javaScript，而对J2EE的研发人员来说，这种方式总有一些别扭。总感觉不是友好的封装，其实只不过是视觉上封装效果不是很好而已，要想达到视觉封装效果而又能达到这种方法的效果的也可以以，个人认为其实比较麻烦。那就是动态原型法。</p><p><span style="font-family:inherit;">5.动态原型</span></p><p><span style="font-family:宋体;">对于习惯使用其他语言的开发者来说，使用混合的构造函数</span><span style="font-family:inherit;">/</span><span style="font-family:宋体;">原型方式感觉不那么和谐。<span style="font-family:inherit;color:rgb(0, 0, 255);">毕竟，定义类时，大多数面向对象语言都对属性和方法进行了视觉上的封装</span>。考虑下面的</span><span style="font-family:inherit;">C#</span><span style="font-family:宋体;">类：</span></p><p>class Car&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//class<br /></span>{<br />&nbsp;&nbsp;&nbsp; public string color = “red”;<br />&nbsp;&nbsp;&nbsp; public int doors = 4;<br />&nbsp;&nbsp;&nbsp; public int mpg = 23;</p><p>&nbsp;&nbsp;&nbsp; public Car(string color, int doors, int mpg)&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//constructor<br /></span>&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.color = color;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.doors = doors;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mpg = mpg;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public void showColor()&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//method<br /></span>&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(this.color);<br />&nbsp;&nbsp;&nbsp; }<br />}</p><p><span style="font-family:inherit;">C#</span><span style="font-family:宋体;">很好的打包了</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">Car</span></span><span style="font-family:宋体;">类的所有属性和方法，因此看见这段代码就知道它要实现什么功能，它定义了一个对象的信息。批评混合的构造函数</span><span style="font-family:inherit;">/</span><span style="font-family:宋体;">原型方式的人认为，在构造函数内存找属性，在其外部找方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。</span></p><p><span style="font-family:宋体;">动态原型方法的基本想法与混合的构造函数</span><span style="font-family:inherit;">/</span><span style="font-family:宋体;">原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。<span style="font-family:inherit;color:rgb(0, 0, 255);">唯一的区别是赋予对象方法的位置。</span>下面是用动态原型方法重写的</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">Car</span></span><span style="font-family:宋体;">类：</span></p><p><span style="font-family:宋体;">&nbsp;&nbsp;&nbsp; &lt;script type=”text/javascript”&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//定义</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function Car() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.color = “red”;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.doors = 4;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.drivers = new Array(“Tom”, “Jerry”);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (typeof Car._initialized == “undefined”) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Car.prototype.showColor = function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//…………<br /></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//最后定义<br /></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Car._initialized = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &lt;/script&gt;</span></p><p><span style="font-family:宋体;">直到检查</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">typeof Car._initialized</span></span><span style="font-family:宋体;">是否等于</span><span style="font-family:Courier;font-size:9.5pt;">“<span style="font-family:inherit;font-size:12.6667px;">undefined</span>“</span><span style="font-family:宋体;">之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">Car._initialized</span></span><span style="font-family:宋体;">设置为</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">true</span></span><span style="font-family:宋体;">。如果这个值定义了（它的值为</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">true</span></span><span style="font-family:宋体;">时，</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">typeof</span></span><span style="font-family:宋体;">的值为</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">Boolean</span></span><span style="font-family:宋体;">），那么就不再创建该方法。简而言之，该方法使用标志（</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">_initialized</span></span><span style="font-family:宋体;">）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，为取悦传统的</span><span style="font-family:inherit;">OOP</span><span style="font-family:宋体;">开发者，这段代码看起来更像其他语言中的类定义了。</span></p><p><span style="font-family:宋体;"><span style="font-family:inherit;">6<span style="font-family:inherit;">&nbsp;&nbsp;</span><span style="font-family:黑体;">混合工厂方式</span></span></span></p><p><span style="font-family:宋体;">&nbsp;&nbsp;&nbsp; var Car = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color: ‘red’,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doors: 4,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; showColor: function() { alert(this.color); }<br />&nbsp;&nbsp;&nbsp; }<br /></span><span style="font-family:宋体;">&nbsp;&nbsp;&nbsp; Car.showColor();</span></p><p><span style="font-family:宋体;">这种方式通常是在不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。这段代码看来与工厂函数非常相似：</span></p><p><span style="font-family:宋体;">function Car() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var oTempCar = new Object();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTempCar.color=”red”;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTempCar.doors=4;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTempCar.mpg=23;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oTempCar.showColor = function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.color);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oTempCar;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="font-family:宋体;">与经典方式不同，这种方式使用</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">new</span></span><span style="font-family:宋体;">运算符，使它看起来像真正的构造函数：<br /></span><span style="font-family:宋体;">var oCar = new Car();<br /></span></p><p>&nbsp;</p><p><span style="font-family:宋体;">由于在</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">Car()</span></span><span style="font-family:宋体;">构造函数内部调用了</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">new</span></span><span style="font-family:宋体;">运算符，所以将忽略第二个</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">new</span></span><span style="font-family:宋体;">运算符（位于构造函数之外）。在构造函数内部创建的对象被传递回变量</span><span style="font-family:inherit;"><span style="font-family:inherit;font-size:9.5pt;">var</span></span><span style="font-family:宋体;">。</span><span style="font-family:宋体;">这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已（请参阅第</span><span style="font-family:inherit;">15</span><span style="font-family:宋体;">章），还是避免使用这种方式。<br /></span><span style="font-family:宋体;"><span style="font-family:黑体;"><span style="font-family:inherit;"><span style="font-family:inherit;color:rgb(0, 0, 255);">总结：（采用哪种方式)<br /></span></span></span></span><span style="font-family:宋体;">目前使用最广泛的是<span style="font-family:inherit;color:rgb(0, 0, 255);">混合的构造函数</span></span><span style="font-family:inherit;"><span style="font-family:inherit;color:rgb(0, 0, 255);">/</span></span><span style="font-family:宋体;"><span style="font-family:inherit;color:rgb(0, 0, 255);">原型方式</span>。此外，<span style="font-family:inherit;color:rgb(0, 0, 255);">动态原型方法</span>也很流行，在功能上与构造函数</span><span style="font-family:inherit;">/</span><span style="font-family:宋体;">原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。<br /></span><span style="font-family:宋体;"><span style="font-family:inherit;color:rgb(0, 128, 0);">//ps<br /></span></span><span style="font-family:宋体;"><span style="font-family:inherit;color:rgb(0, 128, 0);">//static class (1:function)<br /></span>&nbsp;&nbsp;&nbsp; var CarCollection = new function() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var _carCollection = new Array();&nbsp;<span style="font-family:inherit;color:rgb(0, 128, 0);">//global,private<br /></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add = function(objCar) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(‘Add’);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Get = function(carid) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(‘Get’);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</span></p><p><span style="font-family:宋体;"><span style="font-family:inherit;color:rgb(0, 128, 0);">//static class&nbsp;(2:json)</span></span></p><br />